(*here we make Carathedory«s theorem explicit : the last function
general , whose type is Vector.t Tidel.set -> Caratheodory_point_basis Tidel.set,
computes for a list l of vectors a list lb of bases such that the 
pointed cone generated by l is the union of the pointed cones 
generated by the bases in lb. *)

type basis=Basis of (Vector.t Tidel.set);;

let two_parts l=
  let temp1=List.partition(function (x,y)->Rational.is_negative x)(l) in
  let temp2=List.filter(function (x,y)->Rational.is_positive x)(snd temp1) in
  (Image.image(snd)(fst temp1),Image.image(snd)(temp2));;
  
let belong vec (Basis basis)= 
  match Vector.write_as_linear_combination(vec)(Tidel.forget_order basis) with
  None->failwith("The vector is outside range")
  |Some(l)->List.for_all Rational.is_nonnegative l;;
  
  
 let describe (Basis basis) l=
  let temp1=Vector.inverse_matrix(Tidel.forget_order basis) in
  let temp2=Image.image(snd)(temp1) in
  let temp3=List.combine(l)(temp2) in
  let n=Tidel.length(basis) in
  let tempf=(fun i (anv,v)->(List.nth v i,anv)  ) in
  let tempg=(function i->
     let ttemp1=Image.image(tempf i)(temp3) in
     let ttemp2=List.filter(function (z,anv)->z<>Rational.zero)(ttemp1) in 
        Vector.unsafe_vector ttemp2
     ) in
  Ennig.doyle(tempg)(0)(n-1);;
  
  
 let read_dual basis l=
  let temp1=describe(basis)(l) in
  Image.image (Vector.print_inequality) temp1;;

type basis_set=basis Tidel.set;;

let core_operation new_vector (Basis basis)=
  let temp1=Option.unpack(Vector.write_as_linear_combination
            (new_vector)(Tidel.forget_order basis)) in
  let temp2=List.combine(temp1)(Tidel.forget_order basis) in
  let temp3=two_parts(temp2) in
  let neg_part=fst(temp3)
  and pos_part=snd(temp3) in
  let neg=List.length(neg_part)+1
  and pos=List.length(pos_part) in
  if (neg=1)
  then (Tidel.singleton(Basis basis):basis_set)
  else if (pos=0)
       then failwith("The cone is not pointed")
       else let whole=Tidel.teuzin(basis)(Tidel.singleton new_vector) in
            if (neg<pos)
            then Tidel.diforchan(List.rev_map
                     (function x->Basis(Tidel.lemel whole (Tidel.singleton x) ))
                     (new_vector::neg_part))
            else Tidel.diforchan(List.rev_map
                     (function x->Basis(Tidel.lemel whole (Tidel.singleton x) ))
                     (pos_part));;         
                     
 let fold_operation (lb:basis_set) new_vector=
   let llb=Tidel.forget_order(lb) in
   let temp1=List.rev_map(core_operation new_vector)(llb) in
   ((Tidel.big_teuzin temp1):basis_set);;
   
let operation diazez l=List.fold_left 
   fold_operation (Tidel.singleton diazez)  l;;
   
let general_operation l=
 let tl=Tidel.diforchan(l) in
 let b=Tidel.diforchan(Vector.extract_basis l) in
 let peurrest=(Tidel.forget_order (Tidel.lemel tl b)) in
 operation (Basis b) peurrest;;
 
 
 
 
 
 
 
 
 